<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kali Linux — Hackeando Ando #1</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; min-height: 100vh; background: #0d1117; display: flex; align-items: center; justify-content: center; font-family: Consolas, "Courier New", monospace; }
    #root { width: 100%; min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 16px; }
    .terminal { width: 100%; max-width: 900px; min-height: 70vh; max-height: 90vh; background: #0a0a0a; border-radius: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); display: flex; flex-direction: column; overflow: hidden; }
    .terminal-header { padding: 8px 14px; background: #1a1a1a; border-bottom: 1px solid #2d2d2d; color: #00ff00; font-size: 0.85rem; }
    .terminal-body { flex: 1; padding: 16px; overflow: hidden; display: flex; flex-direction: column; }
    .terminal-output { flex: 1; min-height: 200px; overflow-y: auto; color: #00ff00; font-size: clamp(14px, 2.2vh, 18px); line-height: 1.5; white-space: pre-wrap; word-break: break-all; scroll-behavior: smooth; }
    .terminal-output .line { margin-bottom: 2px; }
    .terminal-output .line-prompt, .terminal-output .line-banner { color: #00ff00; }
    .terminal-output .line-output { color: #e6e6e6; }
    .terminal-output .line-error { color: #ff6b6b; }
    .terminal-line { display: flex; align-items: center; margin-top: 8px; flex-shrink: 0; }
    .terminal-line .prompt { color: #00ff00; flex-shrink: 0; margin-right: 4px; }
    .terminal-input { flex: 1; background: transparent; border: none; outline: none; color: #00ff00; font: inherit; font-size: inherit; caret-color: #00ff00; }
    .terminal-input:focus-visible { outline: 2px solid rgba(0,255,0,0.6); outline-offset: 2px; border-radius: 2px; }
    .terminal-line::after { content: ""; display: inline-block; width: 10px; height: 1.1em; background: #00ff00; animation: bl 1s step-end infinite; margin-left: 2px; vertical-align: text-bottom; }
    @keyframes bl { 50% { opacity: 0; } }
    .presentation-controls { padding: 12px 16px; background: #1a1a1a; border-top: 1px solid #2d2d2d; display: flex; align-items: center; gap: 16px; flex-wrap: wrap; }
    .btn-next { font-family: inherit; font-size: 0.95rem; padding: 10px 20px; min-height: 44px; min-width: 120px; background: #00ff00; color: #0a0a0a; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; transition: background 0.15s ease; }
    .btn-next:hover { background: #00cc00; }
    .btn-next:focus-visible { outline: 2px solid #0a0a0a; outline-offset: 2px; }
    .scene-indicator { color: #888; font-size: 0.85rem; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-presets="react">
    const { useState, useRef, useEffect, useCallback } = React;

    const PROMPT = 'root@kali:~# ';
    const TYPING_DELAY_MS = 15;
    const USE_TYPING = true;

    const commands = {
      whoami: { output: 'root' },
      'uname -a': { output: 'La importancia de la Ciberseguridad\n\nLa escasez de habilidades en ciberseguridad es un tema global, pero algunas regiones enfrentan mayores desafíos que otras. Aquí está un desglose de las inequidades en la disponibilidad de habilidades:\n\n- Latinoamérica y el Caribe tienen la mayor escasez de profesionales de ciberseguridad per cápita.\n- Europa y Norteamérica tienen mejor acceso a profesionales capacitados, pero la demanda sigue superando la oferta.\n\nSource: Global Cybersecurity Outlook 2026 - WEF' },
      uname: { output: 'La importancia de la Ciberseguridad\n\nLa escasez de habilidades... (escribe uname -a para texto completo)' },
      nmap: { output: 'Nmap 7.94 ( https://nmap.org )\nUsage: nmap [Scan Type(s)] [Options] {target specification}\n\nHackeando Ando #1 — Herramientas como nmap son parte del kit de Kali.' },
      'nmap --help': { output: 'Nmap 7.94 ( https://nmap.org )\nUsage: nmap [Scan Type(s)] [Options] {target specification}\n\nHackeando Ando #1 — Primeros pasos en hacking ético.' },
      'echo "Hackeando Ando #1"': { output: 'Hackeando Ando #1' },
      'echo hackeando ando': { output: 'hackeando ando' },
      help: { output: 'Comandos: whoami  uname -a  vulnerabilidades  1  mercado  devsecops  2  secure  nmap  echo "..."  social-engineer  help / ?' },
      '?': { output: 'Comandos: whoami  uname -a  vulnerabilidades  1  mercado  devsecops  2  secure  nmap  echo "..."  social-engineer  help / ?' },
      'social-engineer': { output: '[!] Ingeniería social: uso de la manipulación humana para obtener información o acceso.\n\nEn Hackeando Ando #1 hablaremos de cómo reconocerla y mitigarla.' },
      vulnerabilidades: { output: '1. Las empresas no saben qué tan vulnerables son\n\n- El 70-80% de empresas nunca han hecho un pentest real\n- Las auditorías tradicionales son costosas y lentas\n- La seguridad se implementa tarde, cuando ya hubo un incidente.\n\nEl mercado está desprotegido, no solo desabastecido.' },
      '1': { output: '1. Las empresas no saben qué tan vulnerables son\n\n- El 70-80% de empresas nunca han hecho un pentest real\n- Las auditorías tradicionales son costosas y lentas\n- La seguridad se implementa tarde, cuando ya hubo un incidente.\n\nEl mercado está desprotegido, no solo desabastecido.' },
      mercado: { output: '2. El mercado está evolucionando hacia un enfoque de seguridad continua, donde las prácticas de DevSecOps están reemplazando las auditorías puntuales, la automatización se está convirtiendo en el estándar para proteger aplicaciones y procesos, y las startups de ciberseguridad basadas en modelos SaaS están creciendo rápidamente para responder a esta nueva demanda empresarial.' },
      devsecops: { output: '2. El mercado está evolucionando hacia un enfoque de seguridad continua, donde las prácticas de DevSecOps están reemplazando las auditorías puntuales, la automatización se está convirtiendo en el estándar para proteger aplicaciones y procesos, y las startups de ciberseguridad basadas en modelos SaaS están creciendo rápidamente para responder a esta nueva demanda empresarial.' },
      '2': { output: '2. El mercado está evolucionando hacia un enfoque de seguridad continua, donde las prácticas de DevSecOps están reemplazando las auditorías puntuales, la automatización se está convirtiendo en el estándar para proteger aplicaciones y procesos, y las startups de ciberseguridad basadas en modelos SaaS están creciendo rápidamente para responder a esta nueva demanda empresarial.' },
      secure: { output: 'Si todo será software, todo debe ser seguro.' },
      'software-seguro': { output: 'Si todo será software, todo debe ser seguro.' },
      clear: { output: null },
    };

    const banner = [
      '', '  _  __    _    _   _ ____  _   _    _    ____  _   _ ____  _     ___ _   _ _____ ',
      " | |/ /   / \\  | \\ | |  _ \\| | | |  / \\  / ___|| | | | __ )| |   |_ _| \\ | | ____|",
      " | ' <   / _ \\ |  \\| | | | | | | | / _ \\ \\___ \\| | | |  _ \\| |    | ||  \\| |  _|  ",
      ' | . \\ / ___ \\| |\\  | |_| | |_| |/ ___ \\ ___) | |_| | |_) | |___ | || |\\  | |___ ',
      ' |_|\\_/_/   \\_\\_| \\_|____/ \\___/_/   \\_\\____/ \\___/|____/|_____|___|_|_| \\_|_____|',
      '', '  Hackeando Ando #1 — Primer Encuentro Tech & Ciberseguridad',
      '  BruteKaliSecurity · BeNetwork Coworking · Medellín', '', "  Escribe 'help' o '?' para ver comandos.", ''
    ].join('\n');

    const scenes = [
      { command: 'whoami', output: commands.whoami.output },
      { command: 'uname -a', output: commands['uname -a'].output },
      { command: 'vulnerabilidades', output: commands.vulnerabilidades.output },
      { command: 'mercado', output: commands.mercado.output },
      { command: 'secure', output: commands.secure.output },
      { command: 'nmap --help', output: commands['nmap --help'].output },
      { command: 'echo "Hackeando Ando #1"', output: commands['echo "Hackeando Ando #1"'].output },
      { command: 'social-engineer', output: commands['social-engineer'].output },
      { command: 'help', output: commands.help.output },
    ];

    let lineId = 0;
    function nextId() { return ++lineId; }
    function findCommand(trimmed) {
      const key = trimmed.toLowerCase();
      if (commands[key]) return commands[key];
      for (const k of Object.keys(commands)) {
        if (k.toLowerCase() === key) return commands[k];
      }
      return null;
    }

    function Terminal() {
      const [lines, setLines] = useState(() => [{ id: nextId(), type: 'banner', content: banner }]);
      const [inputValue, setInputValue] = useState('');
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const [sceneIndex, setSceneIndex] = useState(0);
      const [typing, setTyping] = useState(null);
      const outputRef = useRef(null);
      const inputRef = useRef(null);

      const scrollToBottom = useCallback(() => {
        if (outputRef.current) outputRef.current.scrollTop = outputRef.current.scrollHeight;
      }, []);

      useEffect(() => { scrollToBottom(); }, [lines, typing]);

      useEffect(() => {
        if (!typing) return;
        const { content, isError } = typing;
        if (typing.displayedLength >= content.length) {
          setLines(prev => [...prev, { id: nextId(), type: isError ? 'error' : 'output', content }]);
          setTyping(null);
          return;
        }
        const t = setTimeout(() => {
          setTyping(prev => prev ? { ...prev, displayedLength: prev.displayedLength + 1 } : null);
        }, TYPING_DELAY_MS);
        return () => clearTimeout(t);
      }, [typing]);

      const runCommand = useCallback((cmd) => {
        const trimmed = cmd.trim();
        if (!trimmed) return;
        setLines(prev => [...prev, { id: nextId(), type: 'prompt', content: PROMPT + trimmed }]);
        setHistory(prev => { const n = [...prev, trimmed]; setHistoryIndex(n.length); return n; });

        const match = findCommand(trimmed);
        if (match) {
          if (match.output === null) { setLines([]); return; }
          if (USE_TYPING && match.output) {
            setTyping({ content: match.output, isError: false, displayedLength: 0 });
          } else {
            setLines(prev => [...prev, { id: nextId(), type: 'output', content: match.output || '' }]);
          }
        } else {
          const msg = "Comando no encontrado: '" + trimmed + "'. Escribe 'help' o '?'.";
          if (USE_TYPING) setTyping({ content: msg, isError: true, displayedLength: 0 });
          else setLines(prev => [...prev, { id: nextId(), type: 'error', content: msg }]);
        }
      }, []);

      const nextScene = useCallback(() => {
        if (sceneIndex >= scenes.length) return;
        runCommand(scenes[sceneIndex].command);
        setSceneIndex(i => i + 1);
      }, [sceneIndex, runCommand]);

      const handleKeyDown = (e) => {
        if (e.key === 'Enter') { e.preventDefault(); runCommand(inputValue); setInputValue(''); return; }
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (history.length === 0) return;
          const idx = Math.max(0, historyIndex - 1);
          setHistoryIndex(idx);
          setInputValue(history[idx]);
          return;
        }
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (history.length === 0) return;
          const idx = Math.min(history.length, historyIndex + 1);
          setHistoryIndex(idx);
          setInputValue(idx >= history.length ? '' : history[idx]);
          return;
        }
      };

      useEffect(() => {
        const fn = (e) => {
          if ((e.key === ' ' || e.key === 'ArrowRight') && e.target !== inputRef.current) {
            e.preventDefault();
            nextScene();
          }
        };
        window.addEventListener('keydown', fn);
        return () => window.removeEventListener('keydown', fn);
      }, [nextScene]);

      useEffect(() => { inputRef.current?.focus(); }, []);

      const sceneLabel = sceneIndex === 0 && history.length === 0
        ? 'Espacio o → para avanzar · ' + scenes.length + ' pantallas'
        : sceneIndex < scenes.length
          ? (sceneIndex + 1) + ' / ' + scenes.length
          : 'Listo. Escribe comandos cuando quieras.';

      return (
        <div className="terminal">
          <div className="terminal-header">
            <span className="terminal-title">root@kali — Hackeando Ando #1</span>
          </div>
          <div className="terminal-body">
            <div className="terminal-output" ref={outputRef}>
              {lines.map(line => (
                <div key={line.id} className={'line line-' + line.type}>
                  {line.content.split('\n').map((s, i, arr) => (
                    <span key={i}>{s}{i < arr.length - 1 && <br />}</span>
                  ))}
                </div>
              ))}
              {typing && (
                <div className={'line line-' + (typing.isError ? 'error' : 'output')}>
                  {typing.content.slice(0, typing.displayedLength).split('\n').map((s, i, arr) => (
                    <span key={i}>{s}{i < arr.length - 1 && <br />}</span>
                  ))}
                </div>
              )}
            </div>
            <div className="terminal-line">
              <span className="prompt">{PROMPT}</span>
              <input
                ref={inputRef}
                type="text"
                className="terminal-input"
                value={inputValue}
                onChange={e => setInputValue(e.target.value)}
                onKeyDown={handleKeyDown}
                autoComplete="off"
                spellCheck={false}
                aria-label="Comando"
                placeholder="Escribe un comando..."
              />
            </div>
          </div>
          <div className="presentation-controls">
            <button type="button" className="btn-next" onClick={nextScene} title="Avanzar con Espacio o flecha derecha" aria-label="Siguiente escena">Siguiente</button>
            <span className="scene-indicator">{sceneLabel}</span>
          </div>
        </div>
      );
    }

    const root = document.getElementById('root');
    if (root) {
      ReactDOM.createRoot(root).render(<Terminal />);
    }
  </script>
</body>
</html>
